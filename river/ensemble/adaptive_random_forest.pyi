import abc
import typing
from river import base as base, metrics as metrics, stats as stats, tree as tree
from river.drift import ADWIN as ADWIN
from river.tree._nodes import RandomLearningNodeAdaptive as RandomLearningNodeAdaptive, RandomLearningNodeMC as RandomLearningNodeMC, RandomLearningNodeMean as RandomLearningNodeMean, RandomLearningNodeModel as RandomLearningNodeModel, RandomLearningNodeNB as RandomLearningNodeNB, RandomLearningNodeNBA as RandomLearningNodeNBA
from river.utils.skmultiflow_utils import check_random_state as check_random_state
from typing import Any

class BaseForest(base.EnsembleMixin, metaclass=abc.ABCMeta):
    models: Any = ...
    n_models: Any = ...
    max_features: Any = ...
    lambda_value: Any = ...
    metric: Any = ...
    disable_weighted_vote: Any = ...
    drift_detector: Any = ...
    warning_detector: Any = ...
    seed: Any = ...
    def __init__(self, n_models: int, max_features: typing.Union[bool, str, int], lambda_value: int, drift_detector: typing.Union[base.DriftDetector, None], warning_detector: typing.Union[base.DriftDetector, None], metric: typing.Union[metrics.MultiClassMetric, metrics.RegressionMetric], disable_weighted_vote: Any, seed: Any) -> None: ...
    def learn_one(self, x: dict, y: base.typing.Target, **kwargs: Any) -> Any: ...
    def reset(self) -> None: ...

class BaseTreeClassifier(tree.HoeffdingTreeClassifier):
    max_features: Any = ...
    seed: Any = ...
    def __init__(self, max_features: int=..., grace_period: int=..., max_depth: int=..., split_criterion: str=..., split_confidence: float=..., tie_threshold: float=..., leaf_prediction: str=..., nb_threshold: int=..., nominal_attributes: list=..., attr_obs: str=..., attr_obs_params: dict=..., seed: Any=..., **kwargs: Any) -> None: ...
    def new_instance(self): ...

class BaseTreeRegressor(tree.HoeffdingTreeRegressor):
    max_features: Any = ...
    seed: Any = ...
    def __init__(self, max_features: int=..., grace_period: int=..., max_depth: int=..., split_confidence: float=..., tie_threshold: float=..., leaf_prediction: str=..., leaf_model: base.Regressor=..., model_selector_decay: float=..., nominal_attributes: list=..., attr_obs: str=..., attr_obs_params: dict=..., min_samples_split: int=..., seed: Any=..., **kwargs: Any) -> None: ...
    def new_instance(self): ...

class AdaptiveRandomForestClassifier(BaseForest, base.Classifier):
    grace_period: Any = ...
    max_depth: Any = ...
    split_criterion: Any = ...
    split_confidence: Any = ...
    tie_threshold: Any = ...
    leaf_prediction: Any = ...
    nb_threshold: Any = ...
    nominal_attributes: Any = ...
    attr_obs: Any = ...
    attr_obs_params: Any = ...
    max_size: Any = ...
    memory_estimate_period: Any = ...
    kwargs: Any = ...
    def __init__(self, n_models: int=..., max_features: typing.Union[bool, str, int]=..., lambda_value: int=..., metric: metrics.MultiClassMetric=..., disable_weighted_vote: Any=..., drift_detector: typing.Union[base.DriftDetector, None]=..., warning_detector: typing.Union[base.DriftDetector, None]=..., grace_period: int=..., max_depth: int=..., split_criterion: str=..., split_confidence: float=..., tie_threshold: float=..., leaf_prediction: str=..., nb_threshold: int=..., nominal_attributes: list=..., attr_obs: str=..., attr_obs_params: dict=..., max_size: int=..., memory_estimate_period: int=..., seed: int=..., **kwargs: Any) -> None: ...
    def predict_proba_one(self, x: dict) -> typing.Dict[base.typing.ClfTarget, float]: ...

class AdaptiveRandomForestRegressor(BaseForest, base.Regressor):
    grace_period: Any = ...
    max_depth: Any = ...
    split_confidence: Any = ...
    tie_threshold: Any = ...
    leaf_prediction: Any = ...
    leaf_model: Any = ...
    model_selector_decay: Any = ...
    nominal_attributes: Any = ...
    attr_obs: Any = ...
    attr_obs_params: Any = ...
    min_samples_split: Any = ...
    max_size: Any = ...
    memory_estimate_period: Any = ...
    kwargs: Any = ...
    aggregation_method: Any = ...
    def __init__(self, n_models: int=..., max_features: Any=..., aggregation_method: str=..., lambda_value: int=..., metric: metrics.RegressionMetric=..., disable_weighted_vote: Any=..., drift_detector: base.DriftDetector=..., warning_detector: base.DriftDetector=..., grace_period: int=..., max_depth: int=..., split_confidence: float=..., tie_threshold: float=..., leaf_prediction: str=..., leaf_model: base.Regressor=..., model_selector_decay: float=..., nominal_attributes: list=..., attr_obs: str=..., attr_obs_params: dict=..., min_samples_split: int=..., max_size: int=..., memory_estimate_period: int=..., seed: int=..., **kwargs: Any) -> None: ...
    def predict_one(self, x: dict) -> base.typing.RegTarget: ...
    @property
    def valid_aggregation_method(self): ...

class BaseForestMember(metaclass=abc.ABCMeta):
    index_original: Any = ...
    model: Any = ...
    created_on: Any = ...
    is_background_learner: Any = ...
    metric: Any = ...
    background_learner: Any = ...
    last_drift_on: int = ...
    last_warning_on: int = ...
    n_drifts_detected: int = ...
    n_warnings_detected: int = ...
    drift_detector: Any = ...
    warning_detector: Any = ...
    def __init__(self, index_original: int, model: typing.Union[BaseTreeClassifier, BaseTreeRegressor], created_on: int, drift_detector: base.DriftDetector, warning_detector: base.DriftDetector, is_background_learner: Any, metric: typing.Union[metrics.MultiClassMetric, metrics.RegressionMetric]) -> None: ...
    def reset(self, n_samples_seen: Any) -> None: ...
    def learn_one(self, x: dict, y: base.typing.Target, sample_weight: int, n_samples_seen: int) -> Any: ...

class ForestMemberClassifier(BaseForestMember, base.Classifier):
    def __init__(self, index_original: int, model: BaseTreeClassifier, created_on: int, drift_detector: base.DriftDetector, warning_detector: base.DriftDetector, is_background_learner: Any, metric: metrics.MultiClassMetric) -> None: ...
    def predict_one(self, x: Any): ...
    def predict_proba_one(self, x: Any): ...

class ForestMemberRegressor(BaseForestMember, base.Regressor):
    def __init__(self, index_original: int, model: BaseTreeRegressor, created_on: int, drift_detector: base.DriftDetector, warning_detector: base.DriftDetector, is_background_learner: Any, metric: metrics.RegressionMetric) -> None: ...
    def reset(self, n_samples_seen: Any) -> None: ...
    def predict_one(self, x: Any): ...
