from abc import ABCMeta, abstractmethod
from collections import namedtuple
from river import base as base
from river.stats import Var as Var
from river.tree._attribute_test import AttributeSplitSuggestion as AttributeSplitSuggestion, InstanceConditionalTest as InstanceConditionalTest
from typing import Any, Iterator, List, Optional, Union

FoundNode = namedtuple('FoundNode', ['node', 'parent', 'parent_branch'])

class Node(metaclass=ABCMeta):
    def __init__(self, stats: Union[dict, Var]=..., depth: int=..., **kwargs: Any) -> None: ...
    @staticmethod
    def is_leaf() -> bool: ...
    def filter_instance_to_leaf(self, x: dict, parent: Node, parent_branch: int) -> FoundNode: ...
    def path(self, x: Any) -> Iterator[Node]: ...
    def iter_edges(self) -> None: ...
    @property
    def stats(self) -> Union[dict, Var]: ...
    @stats.setter
    def stats(self, new_stats: Union[dict, Var]) -> Any: ...
    @property
    def depth(self) -> int: ...
    @depth.setter
    def depth(self, depth: Any) -> None: ...
    @property
    @abstractmethod
    def total_weight(self) -> float: ...
    def subtree_depth(self) -> int: ...
    def describe_subtree(self, tree: Any, buffer: List[str], indent: int=...) -> Any: ...

class SplitNode(Node):
    def __init__(self, split_test: InstanceConditionalTest, stats: Any, depth: Any, **kwargs: Any) -> None: ...
    @staticmethod
    def is_leaf(): ...
    @property
    def n_children(self) -> int: ...
    @property
    def split_test(self) -> InstanceConditionalTest: ...
    @property
    def total_weight(self) -> float: ...
    def set_child(self, index: int, node: Node) -> Any: ...
    def get_child(self, index: int) -> Union[Node, None]: ...
    def instance_child_index(self, x: dict) -> int: ...
    def filter_instance_to_leaf(self, x: dict, parent: Node, parent_branch: int) -> Any: ...
    def path(self, x: Any) -> None: ...
    def iter_edges(self) -> None: ...
    def subtree_depth(self) -> int: ...
    def describe_subtree(self, tree: Any, buffer: List[str], indent: int=...) -> Any: ...

class LearningNode(Node, metaclass=ABCMeta):
    attr_obs: Any = ...
    attr_obs_params: Any = ...
    def __init__(self, stats: Any, depth: Any, attr_obs: str, attr_obs_params: dict, **kwargs: Any) -> None: ...
    def is_active(self): ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    @property
    def last_split_attempt_at(self) -> float: ...
    @last_split_attempt_at.setter
    def last_split_attempt_at(self, weight: Any) -> None: ...
    @property
    def attribute_observers(self): ...
    @attribute_observers.setter
    def attribute_observers(self, attr_obs: Any) -> None: ...
    @staticmethod
    @abstractmethod
    def new_nominal_attribute_observer() -> Any: ...
    @staticmethod
    @abstractmethod
    def new_numeric_attribute_observer(attr_obs: Any, attr_obs_params: Any) -> Any: ...
    @abstractmethod
    def update_stats(self, y: Any, sample_weight: Any) -> Any: ...
    def update_attribute_observers(self, x: Any, y: Any, sample_weight: Any, nominal_attributes: Any) -> None: ...
    def best_split_suggestions(self, criterion: Any, tree: Any) -> List[AttributeSplitSuggestion]: ...
    def disable_attribute(self, attr_idx: Any) -> None: ...
    def learn_one(self, x: Any, y: Any, *, sample_weight: float = ..., tree: Optional[Any] = ...) -> None: ...
    @abstractmethod
    def leaf_prediction(self, x: Any, *, tree: Any=...) -> dict: ...
    @abstractmethod
    def calculate_promise(self) -> int: ...
