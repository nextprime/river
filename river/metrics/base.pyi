import abc
import collections
import numbers
import typing
from . import confusion
from river import base
from typing import Any, Optional

class Metric(abc.ABC, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def update(self, y_true: Any, y_pred: Any, sample_weight: Any) -> Metric: ...
    @abc.abstractmethod
    def revert(self, y_true: Any, y_pred: Any, sample_weight: Any) -> Metric: ...
    @abc.abstractmethod
    def get(self) -> float: ...
    @property
    @abc.abstractmethod
    def bigger_is_better(self) -> bool: ...
    @abc.abstractmethod
    def works_with(self, model: base.Estimator) -> bool: ...

class ClassificationMetric(Metric, metaclass=abc.ABCMeta):
    cm: Any = ...
    def __init__(self, cm: confusion.ConfusionMatrix=...) -> None: ...
    def update(self, y_true: Any, y_pred: Any, sample_weight: float = ...): ...
    def revert(self, y_true: Any, y_pred: Any, sample_weight: float = ..., correction: Optional[Any] = ...): ...
    @property
    def bigger_is_better(self): ...
    def works_with(self, model: Any) -> bool: ...
    @property
    def requires_labels(self): ...
    def __add__(self, other: Any) -> Metrics: ...
    @property
    def sample_correction(self): ...

class BinaryMetric(ClassificationMetric, metaclass=abc.ABCMeta):
    pos_val: Any = ...
    def __init__(self, cm: Optional[Any] = ..., pos_val: bool = ...) -> None: ...
    def update(self, y_true: bool, y_pred: typing.Union[bool, float, typing.Dict[bool, float]], sample_weight: Any=...) -> BinaryMetric: ...
    def revert(self, y_true: bool, y_pred: typing.Union[bool, float, typing.Dict[bool, float]], sample_weight: Any=..., correction: Any=...) -> BinaryMetric: ...

class MultiClassMetric(ClassificationMetric, metaclass=abc.ABCMeta): ...

class RegressionMetric(Metric, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def update(self, y_true: numbers.Number, y_pred: numbers.Number, sample_weight: numbers.Number) -> RegressionMetric: ...
    @abc.abstractmethod
    def revert(self, y_true: numbers.Number, y_pred: numbers.Number, sample_weight: numbers.Number) -> RegressionMetric: ...
    @property
    def bigger_is_better(self): ...
    def works_with(self, model: Any) -> bool: ...
    def __add__(self, other: Any) -> Metrics: ...

class MultiOutputClassificationMetric(Metric, metaclass=abc.ABCMeta):
    cm: Any = ...
    def __init__(self, cm: confusion.MultiLabelConfusionMatrix=...) -> None: ...
    def update(self, y_true: typing.Dict[typing.Union[str, int], base.typing.ClfTarget], y_pred: typing.Union[typing.Dict[typing.Union[str, int], base.typing.ClfTarget], typing.Dict[typing.Union[str, int], typing.Dict[base.typing.ClfTarget, float]]], sample_weight: numbers.Number=...) -> MultiOutputClassificationMetric: ...
    def revert(self, y_true: typing.Dict[typing.Union[str, int], base.typing.ClfTarget], y_pred: typing.Union[typing.Dict[typing.Union[str, int], base.typing.ClfTarget], typing.Dict[typing.Union[str, int], typing.Dict[base.typing.ClfTarget, float]]], sample_weight: numbers.Number=..., correction: Any=...) -> MultiOutputClassificationMetric: ...
    def works_with(self, model: Any) -> bool: ...
    @property
    def sample_correction(self): ...

class MultiOutputRegressionMetric(Metric, metaclass=abc.ABCMeta):
    def update(self, y_true: typing.Dict[typing.Union[str, int], typing.Union[float, int]], y_pred: typing.Dict[typing.Union[str, int], typing.Union[float, int]], sample_weight: numbers.Number) -> MultiOutputRegressionMetric: ...
    def revert(self, y_true: typing.Dict[typing.Union[str, int], typing.Union[float, int]], y_pred: typing.Dict[typing.Union[str, int], typing.Union[float, int]], sample_weight: numbers.Number) -> MultiOutputRegressionMetric: ...
    def works_with(self, model: Any) -> bool: ...

class Metrics(Metric, collections.UserList):
    str_sep: Any = ...
    def __init__(self, metrics: Any, str_sep: str = ...) -> None: ...
    def update(self, y_true: Any, y_pred: Any, sample_weight: float = ...): ...
    def revert(self, y_true: Any, y_pred: Any, sample_weight: float = ...): ...
    def get(self): ...
    def works_with(self, model: Any) -> bool: ...
    @property
    def bigger_is_better(self) -> None: ...
    @property
    def requires_labels(self): ...
    def __add__(self, other: Any): ...

class WrapperMetric(Metric, metaclass=abc.ABCMeta):
    @property
    @abc.abstractmethod
    def metric(self) -> Any: ...
    def get(self): ...
    @property
    def bigger_is_better(self): ...
    def works_with(self, model: Any): ...
    @property
    def requires_labels(self): ...
    @property
    def __metaclass__(self): ...

class MeanMetric(abc.ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def update(self, y_true: Any, y_pred: Any, sample_weight: float = ...): ...
    def revert(self, y_true: Any, y_pred: Any, sample_weight: float = ...): ...
    def get(self): ...
